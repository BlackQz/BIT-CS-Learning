# 计算机体系结构

## 基本概念

### 系统结构、组成与实现

计算机系统=软件+硬件/固件

从使用语言的角度划分为多级层次结构

#### 计算机体系结构

指的是层次结构中传统机器级的系统结构

- 其界面之上的功能包括操作系统级、 汇编语言级、 高级语言级和应用语言级中所有软件的功能
-  界面之下的功能包括所有硬件和固件的功能

体系结构是是对计算机系统中各级界面的划分、定义及其上下的功能分配。

传统机器语言程序员看到的计算机属性，包括

- 数据表示
- 寻址方式
- 寄存器组织
- 指令系统
- 存储系统组织
- 中断机构
- 管态和用户态的定义和切换
- 机器级IO结构
- 信息保护方式和保护机构

#### 计算机组成

计算机系统结构的逻辑实现，包括机器内数据流和控制流的组成以及逻辑设计

- 数据通路宽度
- 专用部件的设置
- 各种操作对部件的共享程度
- 功能部件的并行度
- 控制机构的组成方式
- 缓冲和排队技术
- 预估、预判技术

#### 计算机实现

计算机组成的物理实现，主要着眼于器件技术和微组装技术  

#### 三者关系

- 系统结构要考虑组成和实现的发展
- 组成要考虑系统结构和实现，决定于系统结构，受限于实现
- 组成与实现不是被动的，折中权衡；  
- 实现是物质基础

### 软硬件取舍和计算机系统的设计思路

#### 设计的主要方法

分界面在传统机器级

- 由上到下
- 由下到上
- 中间开始

### 计算机设计的量化准则

Amdahl定律：系统中某一部件由于采用某种更快的执行方式后整个系统性能的提高与这种执行方式的使用频率或占总执行时间的比例有关  

- 加速比

  <img src="计算机体系结构.assets/image-20210602091504748.png" alt="image-20210602091504748" style="zoom:50%;" /> 或

  <img src="计算机体系结构.assets/image-20210602091522426.png" alt="image-20210602091522426" style="zoom:50%;" />等

- 系统加速比的依赖因素

  - 可改进比例Fe
  - 性能提高比Se

  <img src="计算机体系结构.assets/image-20210602093324320.png" alt="image-20210602093324320" style="zoom:50%;" />
  
- 改进后的加速比为

  <img src="计算机体系结构.assets/image-20210604093142961.png" alt="image-20210604093142961" style="zoom: 50%;" />

- CPU性能公式

  - 时钟频率：主频

  - 指令时钟数CPI：每条指令执行所用的时钟周期数

  - IPC：每个时钟周期执行的指令数

  - 吞吐量：单位时间内处理请求的数量

  - 响应时间：系统对请求作出响应的时间（包括CPU时间和等待时间）

  - 指令速度：

    MIPS

    <img src="计算机体系结构.assets/image-20210604095847562.png" alt="image-20210604095847562" style="zoom:50%;" />

    （吉普森法）

    <img src="计算机体系结构.assets/image-20210604095638583.png" alt="image-20210604095638583" style="zoom:50%;" />

### 对系统结构的影响因素

软件可移植性的几种技术

- 统一高级语言

- 采用系列机思想

  同一厂家生产的具有相同的系统结构，不同组成和实现的一系列计算机系统。  

- 模拟与仿真

  模拟：机器语言-主存中

  - 宿主机
  - 虚拟机

  仿真：微程序-控存中

## 计算机设计的量化准则

## 指令与寻址

### 数据表示

常用数据典型有三类

- 用户定义的数据
- 系统数据
- 指令数据

体系结构研究的首要任务是：数据类型的实现方式（硬件？软件？）

#### 数据表示

可以被硬件直接识别和指令系统直接调用的数据类型

#### 数据结构

结构化数据的组织方式，反映了应用中各种数据元素或信息单元的结构关系，必须通过软件映像变换成机器中所具有的各种数据表示

#### 数据表示和数据结构的关系

- 数据结构是通过软件映像成机器所具有的各种数据表示实现的
- 数据表示是数据结构的组成元素
- 数据类型用数据结构或数据表示实现，实质是软硬件取舍问题



#### 引入数据表示的原则

- 缩短程序运行时间
- 减少CPU与主存储器之间的通信量
- 这种数据表示的通用性和利用率是否很高

### 寻址方式

体系结构研究重点：分析各种寻址技术的优缺点，选择和确定寻址技术



### 指令系统的设计和优化

指令=操作码+地址码

操作码主要包括两部分

- 操作种类
- 操作数描述

地址码通常包括三部分

- 地址
- 地址附加信息
- 寻址方式

#### 指令操作码优化

目的：使操作码字段占用的位数最少

- 信息源熵的概念

  - 信息源包含的平均信息量

  - 对于操作码就是操作码的最短平均码长

  - 计算公式为

    <img src="计算机体系结构.assets/image-20210326092834910.png" alt="image-20210326092834910" style="zoom:67%;" />

- 信息冗余量

  <img src="计算机体系结构.assets/image-20210326093147138.png" alt="image-20210326093147138" style="zoom:67%;" />

- 实际平均码长

  <img src="计算机体系结构.assets/image-20210326093208949.png" alt="image-20210326093208949" style="zoom:67%;" />

三种编码方式（建议找题自己算一算）

- 固定长度编码
- Huffman编码
- 扩展编码

#### 指令地址码优化

- 用比较短的地址表示比较大的虚拟空间
- 可变长操作码与可变长地址码配合

### 指令系统的改进与发展

两种方向

- 增强指令系统功能（软件功能硬化，CISC）
- 简化指令系统（精简指令，RISC）

#### 按照CISC方向改进指令系统

目标：强化指令功能，减少指令条数

- 面向目标程序的优化实现

  方法

  - 利用哈夫曼思想改进指令
  - 增设强功能复合指令

- 面向高级语言的优化实现

  方法

  - 统计使用频度来改进指令
  - 面向编译、优化代码生成来改进指令，增强指令系统的规整性
  - 缩小指令系统与各种语言的语义差异
  - 让机器具有多种指令系统
  - 发展高级语言计算机

- 面向操作系统的优化实现

  方法

  - 统计使用频度来改进指令
  - 增设专用于OS的新指令
  - 用硬件或固件实现OS的某些功能
  - 由专门处理机完成OS

CISC存在的问题

- 日益庞大复杂的指令系统实现越来越困难，可能降低系统性能
- 最常使用的是一些比较简单的指令，仅占指令总数的20%，剩下的是使用频度很低的指令
- 复杂指令使指令的执行周期大大加长
- 增强了指令系统功能，简化了软件，但硬件变复杂了
- 规整性不足

#### 按照RISC方向改进指令系统

设计基本原则

- 只选用频度很高的指令和关键指令，条数很少
- 减少寻址方式的种类
- 简化指令格式，限制在两种内，且具有**相同长度**
- 所有指令在**一个机器周期**内完成
- 扩大通用寄存器个数，一般大于等于32
- 尽可能减少访存，仅Load和Store指令可以访问存储器
- 大部分指令通过硬联控制，提高速度
- 优化设计编译程序，以简单有效方式支持高级语言实现

注意，**减少CPI**使RISC的精华

优点

- 简化了指令系统设计，适合VLI实现
- 提高了执行速度和效率
- 降低了成本，提高了可靠性
- 提供直接支持高级语言的能力，简化了编译程序设计

缺点

- 增大了程序占用空间，加重了汇编程序员负担
- 对浮点运算和虚拟存储器支持不够理想
- 较难编写

#### 设计RISC的关键技术

- 重叠寄存器窗口技术

  减少因传送参数而访问存储的次数

  让每个过程使用一个有限数量的寄存器窗口，并让各过程窗口部分重叠

  <img src="计算机体系结构.assets/image-20210327151109815.png" alt="image-20210327151109815" style="zoom:67%;" />

- 流水线技术

  本条指令的执行与下一条指令的预取**重叠**

  <img src="计算机体系结构.assets/image-20210327151332738.png" alt="image-20210327151332738" style="zoom:67%;" />

- 延迟转移技术

  为避免无条件转移指令或成功条件转移指令造成指令预取浪费，流水线断流等问题，采用延迟转移，即在**转移指令后**插入一条不相关的有效指令

  限制条件

  - 被移动的指令在移动过程中与经过的指令不能有数据相关
  - 被移动的指令不破坏条件码

- 指令取消技术

  采用指令延迟时，许多情况下找不到可调整的指令，故采用指令取消技术，

  - 向后转移（循环程序）

    循环体第一条指令经过调整后安排在两个位置

    - 循环体前
    - 循环体后，转移成功时执行

    <img src="计算机体系结构.assets/image-20210327152314597.png" alt="image-20210327152314597" style="zoom:80%;" />

  - 向前转移（if-then)

    方法：如果转移不成功执行下一条指令，否则取消下一条指令

  - 隐含转移

    场合：用于if-then，且then部分只有一条指令

    方法：if条件取反，如果取反后条件成立则取消下条指令，否则执行

- 指令流调整技术

  通过变量重新命名消除数据相关，提高流水线执行效率

  <img src="计算机体系结构.assets/image-20210327152703733.png" alt="image-20210327152703733" style="zoom:80%;" />

- 优化编译系统设计的技术

  RISC使用了大量寄存器，编译程序必须优化寄存器的分配和使用

## 输入输出系统

主要功能是对指定外设进行输入输出操作

### 概述

特性

- 异步性：各设备按照自己的时钟工作
- 实时性：处理机必须及时处理设备
- 与设备无关性：独立于具体设备的标准接口，外设通过标准接口与其连接

组织方式

- 针对**异步性**，采用自治控制

  输入输出系统独立于处理机之外

- 针对**实时性**，采用层次结构

  - 最靠近处理机的是输入输出处理机、输入输出通道等。
  - 中间层是标准接口
  - 标准接口通过设备控制器与输入输出设备相连
  - 设备控制器控制外围设备工作

- 针对**与设备无关性**，采用分类处理

三个发展阶段，对应三种方式

- 程序控制输入输出
- 直接存储器访问（DMA）
- I/O处理机方式

### 磁盘阵列RAID

独立冗余磁盘阵列

- RAID0：无冗余无校验的磁盘阵列

  所有磁盘并行工作，各自读出对应部分，不提供数据冗余

- RAID1：镜像磁盘阵列

  每次写入数据时，都会将数据复制到其镜像盘上。

- RAID2：纠错海明码磁盘阵列

  每个数据盘存放数据字的一位，还需要3个磁盘来存放海明校验位

- RAID3：位交叉奇偶校验的磁盘阵列

  RAID2的简化版本，校验盘专门存放数据盘中相应数据的奇偶校验位

- RAID4：块交叉奇偶校验的磁盘阵列

  以块为单位进行交叉存储和计算奇偶校验

- RAID5：无独立校验盘的奇偶校验磁盘阵列

  每一行数据块的校验块被均匀存放到不同盘中

- RAID6：双维无独立校验盘的奇偶校验磁盘阵列

  增加了第二个独立的奇偶校验信息块

影响RAID级别选择的因素为：可用性、性能、成本

- 选择RAID0获得最佳性能
- 如果成本不是主要因素，根据硬盘数量可选择RAID1

### 总线设计

总线特点

- 总线是一组能为多个部件**分时共享**的公共信息传送线路

总线事务：在总线上一对设备间一次信息交换过程，通常包括两个阶段，地址阶段和数据阶段

- 主设备：发出总线事务请求，获得总线使用权
- 从设备：与主设备进行信息交换的对象

总线周期：完成一次总线操作的时间

#### 总线类型

按信息传输方向，总线可分为

- 单向传输
- 双向传输
  - 半双向
  - 全双向

按用法可分为

- 专用
- 非专用

#### 总线的数据宽度

数据宽度是I/O设备取得I/O总线后所传送**数据的总量**

- 单字（单字节）宽度适合于低速设备。
- 定长块宽度适合于高速设备，可以充分利用总线带宽。
- 变长块宽度适合于高优先级的中高速设备
- 单字加定长块宽度适合于速度较低而优先级较高的设备
- 单字加变长块宽度是一种灵活有效但却是复杂、花钱的方法

#### 总线的线数

在满足性能要求以及所用通信类型和速率适配的情况下，应尽量减少总线的线数。

#### 总线的性能指标

- 总线宽度。指总线的线数，地址线和数据线的数量有最直接的影响

- 总线带宽，总线最大数据传输速率

  总线带宽=总线宽度×总线频率

- 总线负载：指连接在总线上的最大设备数量

- 总线复用：不同时段利用总线的同一信号线传送不同信号

- 总线猝发传输

#### 总线定时控制

- 同步定时方式

  采用一个统一的时钟信号协调发送和接收方，时钟产生相等的时间间隔，每个间隔构成一个总线周期，在 一个总线周期内，可以进行一次数据传送。

  必须适应延迟最长和最慢的接口的需要

- 异步定时方式（应答方式）

  通过双方握手信号实现定时控制，可保证工作速度相差大的部件进行信息交换

  有三种情况

  - 不互锁：请求和回答信号都有一定时间宽度
  - 半互锁：请求信号的撤销取决于收到回答信号
  - 全互锁：请求信号的撤销取决于收到回答信号，又导致回答信号的撤销

  ![image-20210402111740494](计算机体系结构.assets/image-20210402111740494.png)

#### 总线通信技术

- 同步通信

  同步通信时两个部件之间信息传送时通过定宽、定距的系统时标进行的

- 异步通信

  异步通信又可分为单向控制和双向(请求/回答)控制两种。

  - 单项控制是指通信过程中只由目的或源部件中的一个进行控制

#### 总线控制方式

当采用非专用总线时，由于可能同时有多个设备同时申请使用总线，需要按照优先级进行裁决

- 总线的集中仲裁方式

  总线控制机构中设置总线判优和仲裁控制逻辑，集中在一处

  - 链式查询方式

    使用三根控制线与所有部件和设备相连

    

    <img src="计算机体系结构.assets/image-20210402112430863.png" alt="image-20210402112430863" style="zoom: 50%;" />

    - 总线请求BR：有效表示至少有一个部件或设备要求使用总线
    - 总线忙BS：有效表示总线正被某部件或设备使用
    - 总线批准（总线可用）：有效表示总线控制器相应总线请求

    缺点是对查询链电路故障敏感

  - 计数器定时查询方式

    <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606112520255.png" alt="image-20210606112520255" style="zoom:50%;" />

  - 独立请求方式

    <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606113004525.png" alt="image-20210606113004525" style="zoom:50%;" />

    共需2n+1个控制线

- 总线的分布仲裁方式

  总线控制逻辑分布到总线各个部件中，每次总线操作，只能有一个主方占用总线控制权，但同一时间里可以有一个或多个从方。

  - 自举分布式

    设备优先级固定，请求总线控制权设备会在总线请求线上发送请求信号，同时可从总线上接受请求信号，如果检测到优先级更高的设备发起了请求，则不可以使用总线，否则立刻使用，并向其他设备发送总线忙信号

  - 冲突检测分布式

    设备先侦听总线是否忙，如果不忙则置总线忙，并使用总线。

    如果发生冲突，则延迟一个随机时间后再使用总线以避免冲突

  - 并行竞争分布式

    每个设备都有一个唯一的**仲裁号**，用于并行竞争算法中，每个设备根据仲裁算法决定在一定时间后时占用总线还是撤销总线

### 通道处理机

工作原理：将对外围设备的管理工作从CPU分离出来

- 在用户程序中使用访管指令进入管理程序，由CPU通过管理程序组织一个通道程序并启动通道
- 通道处理器执行通道程序，完成指定的数据输入输出工作
- 通道程序结束后第二次调用管理程序对输入输出请求进行处理

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606114857511.png" alt="image-20210606114857511" style="zoom:50%;" />

#### 通道类型

- 字节多路通道

  用于连接管理多台**低速设备**，包含多个子通道，每个子通道连接一个设备控制器

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606115354291.png" alt="image-20210606115354291" style="zoom:50%;" />

  通道轮流为每个设备传送一个字节

- 选择通道（高速通道）

  可连接多个不同时工作的是被，一次只能执行一个通道程序，完成信息交换后才会执行另一通道程序。只有一个以成组方式工作的子通道，逐个为多台外设服务

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606115543612.png" alt="image-20210606115543612" style="zoom:50%;" />

- 数组多路通道

  结合字节多路通道和选择多路通道的特点，当某设备进行数据传输时，只为该设备服务，当设备在进行辅助操作时，通道暂时挂起该设备的通道程序，为其他设备服务。

  有多个子通道，既可以所有子通道分时共享总通道，也可以成组传送数据。

#### 通道数据传输过程

通道流量：单位时间内能够传送的最大数据量

通道最大流量：通道在满负荷工作状态下的流量

选择一次设备的时间Ts，传送一个字节的时间Td，传输n个字节，每个设备传送k个

三种通道的最大流量为：

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606120850502.png" alt="image-20210606120850502" style="zoom:50%;" />

总数据传输率为

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606120931927.png" alt="image-20210606120931927" style="zoom:50%;" />

## 存储体系

### 存储体系概念和并行存储系统

存储系统：**两个或两个以上**的速度、容量、价格不同的 存储器采用硬件，软件或软、硬件结合的办法联接成的一个系统。

主要性能指标

- 容量

  Sm=W * L * m

  W存储体字长，L存储体字数，m存储体个数

- 速度

  - 访问时间TA：存储器从街道访存申请到开始读数据的时间
  - 存储周期TM：存储器进行一次存取所需要的时间
  - 频宽BM：存储器提供的数据传输率

- 价格

在三个性能指标中，字数、TA、TM主要与器件工艺有关，字长和存储体个数则由系统设计者确定。三者存在矛盾，可以以下措施解决

- 改进工艺和技术
- 构成并行主存系统
- 使用存储器系统（主存、辅存）
- 存储体系

#### 并行存储系统

在一个存储周期内可以访问到多个数据，从而提高主存频宽。

可分为

- 单体单字

  有一个字长为W位的存储器，一次可以访问一个字，最大频宽为BM=W/TM

- 单体多字

  增加存储器字长，在一个贮存周期中读出多个CPU字

- 多体单字交叉存储器

  由多个容量较小、字长较短的相同存储器芯片组成，每个存储器字长都是CPU字长，让多个存储体并行工作

  CPU字在主存中可以按模m交叉编址

  - 高位交叉：用地址码的高位部分区分存储体号

    扩大存储器容量

  - 低位交叉：用地址码的低位部分区分存储体号

    提高存储器访问速度

- 多体多字交叉存储器

  结合多体单字和单体多字的特点

#### 存储体系

对应用程序员透明，速度接近最快的存储器，容量接近最大的存储器

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606141013351.png" alt="image-20210606141013351" style="zoom:50%;" />

- T ≈ min(T1, T2, …, Tn)，用存储周期表示 
- S ≈ max(S1, S2, …, Sn)，用MB或GB表示
- C ≈ min(C1, C2, …, Cn)，用每位的价格表示

存在两种分支

- 虚拟存储系统：解决容量问题

  主存-辅存存储层次，利用了IO处理和CPU**并行**操作的能力，速度接近主存，容量是辅存

  对**应用程序员**透明

- Cache存储系统：解决速度问题

  Cache-主存存储层次，速度是Cache的，容量是主存的

  对**应用程序员**和**系统程序员**都透明

存储层次间传送数据需要预判，其基础是程序的局部性

- 时间局部性：循环导致
- 空间局部性：顺序执行导致

可得出如下结论：

- 不必存放整个程序，只需要存放近期使用过的块或者页即可
- 调入时，一并把数据所在的块或页一起调入

两个原则

- 一致性原则
- 包含原则

#### 存储体系的性能参数

以二级存储体系为例

- 每位价格c<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606142448678.png" alt="image-20210606142448678" style="zoom: 33%;" />

- 命中率H（CPU产生的逻辑地址能在M1中访问到的概率）

  可以利用程序的局部性原理，采用**预取**技术，将相邻n个数据取入M1，不命中率会降低n倍

- 等效访问时间TA

  - 对M1和M2的访问同时启动<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606142621405.png" alt="image-20210606142621405" style="zoom:33%;" />
  - 对M1和M2的访问不是同时启动<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210606142631961.png" alt="image-20210606142631961" style="zoom:33%;" />
  - 访问效率：TA1/TA



### 虚拟存储系统

定义：主存--辅存层次，借助磁盘等外部存储器扩大主存容量，主要解决容量问题，速度是主存的

特点

- 依赖程序局部性原理
- 对应用程序员透明，对系统程序员不透明
- 每道程序都有独立的虚拟存储空间

不同的地址空间

- 程序空间与程序地址

  程序空间：逻辑空间，虚拟存储空间

  程序地址：虚地址，逻辑地址

- 主存空间与主存地址

  主存空间：主存物理空间

  主存地址：物理地址，实地址

- 辅存空间与辅存地址

  辅存空间：辅助物理空间

  辅存地址：辅存物理地址

程序重定位：用户程序在执行前需要经过多个地址转换步骤，用 户程序地址可能有不同的表示形式。

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607080849898.png" alt="image-20210607080849898" style="zoom:50%;" />

可分为

- 静态重定位：在目标程序装入主存时，将程序逻辑地址变换为物理地址
- 动态重定位：在程序执行过程中，CPU访问主存前，由操作系统、辅助硬件完成地址变换

#### 虚拟存储器管理方式

采用地址映像机构实现程序的动态定位，可分为

- 段式管理：将程序按逻辑分段，按段进行调入、调出和管理

  - 每个程序都有一个段表
  - 每个程序段都从0开始编址，可以映射到主存任意位置

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607083152546.png" alt="image-20210607083152546" style="zoom:33%;" />

  优点：便于共享、保护

  缺点：主存利用率低

- 页式管理：将主存空间和程序空间分成页，按页进行调入、调出和管理。

  - 主存空间分成实页
  - 程序空间分成虚页，大小与实页相同
  - 每个虚页都可以装入任意实页中
  - 每个程序设立**页表**作为地址映像表，记录虚页号与实页号的对应关系

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607083837993.png" alt="image-20210607083837993" style="zoom:33%;" />

  优点：对程序员完全透明，主存利用率高

  缺点：页表占用空间，且不便共享、保护

- 段页式管理

  - 主存空间分成实页
  - 程序空间先按照模块分段，每段分成虚页，大小与实页相同
  - 程序通过一个段表和**一组页表**进行定位，每个段都有一个页表

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607084212367.png" alt="image-20210607084212367" style="zoom:33%;" />

  缺点：每次地址变换至少要两次查表，表占用空间较大

目前**页式管理最**为常见

#### 页面失效与页面争用

页面故障（页面失效）：用户虚地址所在的虚页未装入主存，需要从外部辅存调页，进行**外部地址变化**，具有**外页表**

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607090647767.png" alt="image-20210607090647767" style="zoom:33%;" />

页面争用（实页冲突）：两个或两个以上的虚页想进入主存中的同一实页位置的现象，需要进行**页面替换**

#### 页面替换

可分为

- 随机算法RAND
- 先进先出算法FIFO：选最早装入主存的页作为被替换的页
- 最近最少使用算法LFU：选择近期最少访问的页作为被替换的页，实现困难
- 最近最久未使用算法LRU（最常用）：LFU的变形
- 优化替换算法OPT：需要获知未来页面使用情况

具体计算建议找题目练练

几个概念：

- 颠簸：下次就要使用的页面本次被替换出去而发生的连续页面故障的现象。
- 堆栈型替换算法：命中率随着实页数的增加而增加，对m≤n，在任何时刻t，主存页面数集合Bt都满足关系：Bt(m)属于Bt(n)，LRU和OPT是堆栈型，FIFO不是

#### 页式存储虚拟系统面临的问题

- 页面故障的处理

  页面失效应当看作**故障**，由CPU立即响应处理

  选择合适的替换算法，页面大小不可过大

- 提高等效访问速度

  主要影响因素为

  - 尽可能短的访问主存时间
  - 主存命中率

  关键是提高内部地址变换的速度

  两种额外的方法

  - 快慢表

    - 快表：用快速硬件构成小容量的“相联目录表
    - 慢表：原页表

    查表时同时查找快慢表，将快表中不存在的内容从慢表中调入快表，一般采用**LRU**进行页面替换

  - 散列函数

    加大快表容量，会提高命中率，但速度会降低

    可以使用**硬件方法**实现散列函数进行内容访问，使用**相等比较器**避免散列冲突

- 提高命中率和CPU利用率

  主要因素

  - 程序执行过程中页地址流分布情况

  - 所采用的页面替换算法

  - 页面大小

    <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607113418130.png" alt="image-20210607113418130" style="zoom: 33%;" />

  - 主存储器大小

    单调递增，但达到一定值后，命中率几乎不再提高

### 高速缓冲存储器

#### 基本结构

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607121244583.png" alt="image-20210607121244583" style="zoom:33%;" />

特点

- 与CPU采用相同工艺
- 地址映象、变换、替换、调度等由专门的硬件实现
- Cache—主存之间的信息交换对所有程序员都透明
- Cache访问主存的优先级高于其他系统访问主存的优先级
- 除了Cache和CPU有直接的通路外，主存和CPU也有直接的通路，可以实现读直达和写直达

#### 工作原理

- 读取

  将CPU给出的主存地址变换为Cache地址，搜索Cache

  - 命中，访问Cache，向CPU返回Cache中的数据副本
  - 未命中，从主存中读取数据块到Cache中，向CPU返回数据

- 写入

  将CPU给出的主存地址变换为Cache地址，搜索Cache

  - 命中，写Cache，写主存（存在一致性问题）
  - 不命中，写主存

#### 地址映像规则与地址变换

主要解决定位问题

- 将主存中数据装入Cache的哪个位置
- 如何知道主存中的数据已经装入Cache
- 如果命中，如何形成Cache地址并访问主存

地址映像：将主存中数据按某种规则装入Cache并建立两个地址间的对应关系

块冲突：主存中的块要调入Cache中的某个位置，但该位置已经被其他主存块所占用。

典型的地址映像和地址变换方法有

- 全相联映像与变换

  映像规则：主存中任意块都可以装到Cache中的任意一个位置

  地址变换：采用相联存储器构成的目录表，以硬件方式实现

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607125811880.png" alt="image-20210607125811880" style="zoom: 50%;" />

- 直接映像与变换

  映像规则：主存中的每一块只能装入到Cache内唯一一个指定的块位置（一个Cache块对应多个主存块），Cache块号b＝(主存块号B) mod(Cache块数)

  地址变换：从主存地址中取出低位部分即可形成Cahce地址。设置一个按地址访问的区表存储器（称之为区号表），存放Cache中每一块目前被主存中哪个区的对应块所占用。

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607130718087.png" alt="image-20210607130718087" style="zoom:50%;" />

- 组相联映像与变换

  存在很多种方法，只需要记**位选择组相联映象及变换方式**

  映像规则

  - 主存块到Cache组set之间采用直接映像方式

    Cache组号=主存区内块号=主存块号mod组数；

  - 在对应的组内部采用全相联映像方式

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607132948472.png" alt="image-20210607132948472" style="zoom:50%;" />

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607133001724.png" alt="image-20210607133001724" style="zoom:50%;" />

  地址变换：

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607133041244.png" alt="image-20210607133041244" style="zoom:50%;" />

Cache通常使用组相联或直接相联映像，而不采用全相联映像

#### Cache替换算法与实现

当所要访问的块不在Cache中时，则发生块失效。

当所能装入的Cache块都已被装满时，则出现块冲突，必须进行块替换。

典型替换算法包括

- 随机替换算法
- FIFO算法
- LRU算法

实现方式：全部使用硬件

两种方法（重要性存疑，暂不补充）

- 堆栈法
- 比较对法

#### Cache透明性

Cache-主存存储层次对所有程序员透明

Cache内容是主存内容的一小部分副本

但Cache内容有可能与主存内容不一致，存在两种情况

- CPU写Cache
- IO写主存

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607133930587.png" alt="image-20210607133930587" style="zoom:33%;" />

解决Cache问题的关键：写Cache时如何更新主存内容，即**写策略**

- 写命中策略

  - 写直达法

    利用直接通路，把数据**同时写入Cache和主存**

    优点：可靠性强，控制简单

  - 写回法

    - CPU数据只写入Cache，不写入主存
    - 为每个Cache块设置“修改位”
    - 仅当替换时，才把修改过的Cache块写回到主存

    优点：通信量少，硬件实现代价低

- 写不命中策略

  - 不按写分配法：在写Cache不命中时，把所要写的字直接写入主存，不调块，一般配合写直达法
  - 按写分配法：在写Cache不命中时，把所要写的字直接写入主存，不调块，一般配合写回法

预取算法

- 按需取：在出现Cache不命中时，把一个块取到Cache中来
- 恒预取：无论Cache是否命中，都把下一块取到Cache中
- 不命中预取：当Cache不命中，把本块和下一块一起取到Cache中

预取算法对命中率的影响还和块的大小和预取开销有关

造成Cache失效的重要原因是**任务切换**，解决方法参考如下

- 增大Cache容量
- 修改调度算法
- 设置多个Cache

#### Cache性能分析

影响Cache性能的主要因素

- 块大小，块数量
- 采用组相联时，组内块数和组数
- 替换算法
- 地址流
- Cache预取算法等

性能分析：

加速比为<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210607140815690.png" alt="image-20210607140815690" style="zoom:33%;" />

提高Cache系统的加速比SP最好的途径是**提高命中率H**

### Cache -主存-辅存三级层次

程序员使用且只关心一个存储器：

- 访问方式= 按地址随机访问
- 等效速度= Cache
- 等效容量= 虚拟空间容量